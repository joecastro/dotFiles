#! /bin/zsh

# Useful reference: https://scriptingosx.com/2019/07/moving-to-zsh-part-7-miscellanea/

# autoload -Uz promptinit
# promptinit
# prompt fire

setopt PROMPT_SUBST
setopt histignorealldups sharehistory

# Color cheat sheet: https://jonasjacek.github.io/colors/
autoload -U colors && colors

export LSCOLORS="Gxfxcxdxbxegedabagacad" 
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}  

setopt NO_CASE_GLOB
setopt AUTO_CD
setopt EXTENDED_HISTORY

HISTFILE=${ZDOTDIR:-$HOME}/.zsh_history
SAVEHIST=5000
HISTSIZE=2000

setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY

setopt CORRECT

# Vim mode
bindkey -v

bindkey ^R history-incremental-search-backward
bindkey ^S history-incremental-search-forward

bindkey "^[[A" history-beginning-search-backward # up arrow bindkey
bindkey "^[[B" history-beginning-search-forward # down arrow bindkey
bindkey \^U backward-kill-line
bindkey \^W kill-line
bindkey "\e[3~" delete-char

# Use modern completion system
autoload -Uz compinit
compinit

# zstyle ':completion:*' auto-description 'specify: %d'
# zstyle ':completion:*' completer _expand _complete _correct _approximate
# zstyle ':completion:*' format 'Completing %d'
# zstyle ':completion:*' group-name ''
# zstyle ':completion:*' menu select=2
# eval "$(dircolors -b)"
# zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
# zstyle ':completion:*' list-colors ''
# zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
# zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
# zstyle ':completion:*' menu select=long
# zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
# zstyle ':completion:*' use-compctl false
# zstyle ':completion:*' verbose true

# zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'
# zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'

# Vim stuff

# Remove mode switching delay.
KEYTIMEOUT=5

# Set cursor style (DECSCUSR), VT520.
# 0 ‚áí blinking block.
# 1 ‚áí blinking block (default).
# 2 ‚áí steady block.
# 3 ‚áí blinking underline.
# 4 ‚áí steady underline.
# 5 ‚áí blinking bar, xterm.
# 6 ‚áí steady bar, xterm.

function _set_cursor_beam() {
   echo -ne '\e[5 q'
}

function _set_cursor_block() {
   echo -ne '\e[1 q'
}

function zle-keymap-select {
    case $KEYMAP in
        vicmd)
            _set_cursor_block
            ;;
        viins|main)
            _set_cursor_beam
            ;;
    esac
}

zle -N zle-keymap-select

zle-line-finish() { _set_cursor_block }
zle -N zle-line-finish

zle-line-init() { _set_cursor_beam }
zle -N zle-line-init

# Use beam shape cursor for each new prompt.
preexec() { _set_cursor_beam }

function __is_ssh_session() {
    if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ] || [ -n "$SSH_CONNECTION" ]; then
        return 0
    fi
    return 1
}

function wintitle() {
    if [ -z "$1" ]; then
        echo "Missing window title"
    else
        echo -ne "\e]0;$1\a"
    fi
}

# emojipedia.org
ANCHOR_ICON=‚öì
PIN_ICON=üìå
HUT_ICON=üõñ
HOUSE_ICON=üè†
TREE_ICON=üå≤
DISK_ICON=üíæ
OFFICE_ICON=üè¢

ICONS=($ANCHOR_ICON $PIN_ICON $HUT_ICON $HOUSE_ICON $TREE_ICON $DISK_ICON $OFFICE_ICON)

function __cute_pwd() {
    git branch > /dev/null 2>&1;
    if [[ "$?" != "0" ]]; then
        case "${PWD##*/}" in
            random | rnd)
                RANDOM=$$$(date +%s)
                ix=$(($RANDOM % ${#ICONS[@]}))
                echo "r$ICONS[$(($ix+1))]d"
                ;;
            ${HOME##*/})
                echo üè†
                ;;
            /)
                echo üå≤
                ;;
            src | source | master | main)
                echo üíæ
                ;;
            work)
                echo üè¢
                ;;
            *)
                echo -n ${PWD##*/}
                ;;
        esac
    else
        git rev-parse --is-inside-git-dir | grep "true" > /dev/null 2>&1;
        if [[ "$?" != "0" ]]; then
            # If we're in a git repo then show the current directory relative to the root of that repo.
            echo "$ANCHOR_ICON$(git rev-parse --show-toplevel | xargs basename)/$(git rev-parse --show-prefix)" 
        else 
            echo "üöß"
        fi
    fi
}

function __cute_time_prompt() {
    case "$(date +%Z)" in
        UTC)
            echo -n "%Tz"
            ;;
        *)
            echo -n "%T %D{%Z}"
            ;;
    esac
}

function __print_git_worktree() {
    if __is_in_repo && (( ${+SKIP_WORKTREE_IN_ANDROID_REPO} )); then
        echo ""
        return 0
    fi

    git branch > /dev/null 2>&1
    if [[ "$?" != "0" ]]; then
        echo ""
        return 0
    fi

    ROOT_WORKTREE=$(git worktree list | head -n1 | awk '{print $1;}')
    ACTIVE_WORKTREE=$(git worktree list | grep "$(echo `git rev-parse --show-toplevel`)" | head -n1 | awk '{print $1;}')

    if [[ "$ROOT_WORKTREE" == "$ACTIVE_WORKTREE" ]]; then
        echo ""
        return 0
    fi

    SUBMODULE_WORKTREE=$(echo `git rev-parse --show-superproject-working-tree`)
    if [[ "$SUBMODULE_WORKTREE" == "" ]]; then
        echo üå≤"%{$fg[green]%}[${ROOT_WORKTREE##*/}/${ACTIVE_WORKTREE##*/}] "
        return 0
    fi

    echo üõ∂"%{$fg[magenta]%}[${SUBMODULE_WORKTREE##*/}/${ROOT_WORKTREE##*/}] "
    return 0
 
}

function __is_in_repo() {
    verbose=0
    if [[ -z "$1" ]]; then
        unset verbose
    fi

    repo --show-toplevel > /dev/null 2>&1;
    if [[ "$?" == "0" ]]; then
        return 0
    fi
    if (( ${+verbose} )); then
        echo "error: Not in Android repo tree"
    fi
    return 1
}

function __print_repo_worktree() {
    if __is_in_repo; then
        # REPO_ROOT=$(repo --show-toplevel | head -n1 | awk '{print $1;}')
        REPO_ROOT=$(repo info -o --outer-manifest -l | grep -i "Manifest branch" | sed 's/^Manifest branch: //')
        echo ü§ñ"%{$fg[red]%}[${REPO_ROOT##*/}] "
    else
        echo ""
    fi
}

function __print_git_info() {
    git branch > /dev/null 2>&1;
    if [[ "$?" != "0" ]]; then
        echo ""
        return 0
    fi

    git rev-parse --is-inside-git-dir | grep "true" > /dev/null 2>&1
    if [[ "$?" == "0" ]]; then
        echo ""
        return 0
    fi

    echo "$(echo `git status 2>/dev/null` | grep "HEAD detached" > /dev/null 2>&1
    if [ "$?" -eq "0" ]; then
        echo "$(echo `git status 2>/dev/null` | grep "nothing to commit" > /dev/null 2>&1
        if [ "$?" -eq "0" ]; then
            echo -e "%{$fg[red]%}"$(__git_ps1 "%s")" "
        else 
            echo -e "%{$fg[red]%}"$(__git_ps1 "{%s *}")" "
        fi)"
    else
        echo "$(echo `git status 2>/dev/null` | grep "nothing to commit" > /dev/null 2>&1
        if [ "$?" -eq "0" ]; then
            echo -e "%{$fg[green]%}"$(__git_ps1 "(%s)")" "
        else
            echo -e "%{$fg[yellow]%}"$(__git_ps1 "{%s *}")" "
        fi)"
    fi)"
}

#curl -ocurl -o ~/.git-prompt.sh \
#    https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh

if [ ! -f ~/.git-prompt.sh ]; then
    echo "Bootstrapping git-prompt installation on new machine through curl"
    curl -o ~/.git-prompt.sh \
    https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh
fi

# defines __git_ps1
source ~/.git-prompt.sh

if command -v brew > /dev/null; then
    test -e "$(brew --prefix)/opt/zsh-git-prompt/zshrc.sh" && source "$(brew --prefix)/opt/zsh-git-prompt/zshrc.sh"
fi

# Use a different color for displaying the host name when we're logged into SSH
if __is_ssh_session; then
     HostColor=%F{214}
     HostNameDisplay=%M
else
     HostColor=%{$fg[yellow]%}
     HostNameDisplay=%m
fi

function __virtualenv_info(){
    # venv="${VIRTUAL_ENV##*/}"
    test -n "$VIRTUAL_ENV" && echo "üêç "
}

# disable the default virtualenv prompt change
export VIRTUAL_ENV_DISABLE_PROMPT=1

PROMPT='${white}$(__cute_time_prompt) '
# Optional
PROMPT+='$(__virtualenv_info)'
PROMPT+='%{$fg[green]%}$USER%{$fg[yellow]%}@%B$HostColor$HostNameDisplay%{$reset_color%} '
# Optional - spaces are embedded in output suffix if these are non-empty.
PROMPT+='$(__print_repo_worktree)%{$reset_color%}'
# Repo is implemented in terms of worktrees, so this gets noisy.
SKIP_WORKTREE_IN_ANDROID_REPO=1
PROMPT+='$(__print_git_worktree)$(__print_git_info)%{$reset_color%}'
PROMPT+='$(__cute_pwd) $ '
# RPROMPT='%*'

# if exa is installed prefer that to ls
# options aren't the same, but I also need it less often...
if ! command -v exa &> /dev/null; then
    echo "## Using native ls because missing exa"
    # by default, show slashes, follow symbolic links, colorize
    alias ls='ls -FHG'
else
    alias ls=exa
    alias realls='\ls -FHG'
fi

alias myip='curl http://ipecho.net/plain; echo'

function __venv_aware_cd() {
    builtin cd "$@"

    # If I am no longer in the same directory hierarchy as the venv that was last activated, deactivate.
    if [[ -n "$VIRTUAL_ENV" ]]; then
        P_DIR="$(dirname "$VIRTUAL_ENV")"
        if [[ "$PWD"/ != "$P_DIR"/* ]]; then
            echo "üêç Deactivating venv for $P_DIR"
            deactivate
        fi
    fi

    # If I enter a directory with a .venv and I am already activated with another one, let me know but don't activate.
    if [[ -d ./.venv ]]; then
        if [[ -z "$VIRTUAL_ENV" ]]; then
            source ./.venv/bin/activate
            echo "üêç Activating venv with $(python --version) for $PWD/.venv"
        # else: CONSIDER: test "$PWD" -ef "$VIRUAL_ENV" && "üêç Avoiding implicit activation of .venv environment because $VIRTUAL_ENV is already active"
        fi
    fi
}

# Basically this lets me override cd and still get file completion...
function ___venv_aware_cd() {
  ((CURRENT == 2)) &&
  _files -/
}

compdef ___venv_aware_cd __venv_aware_cd

# kill_port_proc <port>
function kill_port_proc() {
    readonly port=${1:?"The port must be specified."}

    lsof -i tcp:"$port" | grep LISTEN | awk '{print $2}'
}

# update_java_home <version>
function __update_java_home() {
    readonly jver=${1:?"Version must be specified"}
    if (( ${+JAVA_HOME} )); then
        path[$path[(i)$JAVA_HOME/bin]]=()
    fi
    export JAVA_HOME=$(/usr/libexec/java_home -v $jver)
    path=($JAVA_HOME/bin $path)
}

# $PATH is tied to $path - Can use one as an array and the other as a scalar.
typeset -U path # force unique values.

if command -v /usr/libexec/java_home &> /dev/null; then
    __update_java_home 11

    alias chjava='__update_java_home'
fi

if command -v hub &> /dev/null; then
    eval "$(hub alias -s)"
fi

# Android build utilities

function repo_find() {
    if __is_in_repo; then
        echo $(repo --show-toplevel)
    else
        echo "$(find . -type d -name '.repo' | sed 's#/\.repo$##')"
    fi
}

function repo_root() {
    pushd $(repo_find)
}

function repo_format() {
    git diff HEAD^ --name-only | xargs -t ${ANDROID_BUILD_TOP}/external/ktfmt/ktfmt.py
    git diff HEAD^ --name-only | xargs -t google-java-format -i --aosp
}

function refresh_build_env() {
    if ! __is_in_repo -v; then
        return 1
    fi

    repo_root
    source ./build/envsetup.sh
    popd

    return 0
}

function repo_clean() {
    if ! __is_in_repo -v; then
        return 1
    fi

    REPO_UPSTREAM_BRANCH=goog/$(repo info -o --outer-manifest -l | grep -i "Manifest branch" | sed 's/^Manifest branch: //')
    repo forall -vc "git checkout $REPO_UPSTREAM_BRANCH && git reset --hard $REPO_UPSTREAM_BRANCH &&  git clean -xfd"
}

function repo_pushd() {
    if ! __is_in_repo -v; then
        return 1
    fi

    if [ $# -lt 1 ]; then
        echo "$funcstack[1] Missing sub-project"
        return 1
    fi

    MOUNT_PATHS=($(repo info --outer-manifest -l | grep "Mount path.*$1$" | sed 's/^Mount path: //'))
    for MOUNT_PATH in "${MOUNT_PATHS[@]}"; do
        if [[ "${MOUNT_PATH##*/}" == "$1" ]]; then
            pushd $MOUNT_PATH
            break
        fi
    done

    if [[ "$MOUNT_PATH" == "$PWD" ]]; then
        return 0
    fi

    echo "Unknown project"
    return 1
}

LOCAL_TERMINAL_CATEGORY="LOGIN"

if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    LOCAL_TERMINAL_CATEGORY="EMBEDDED"
fi

# If using iTerm2, try for shell integration.
# When in SSH TERM_PROGRAM isn't getting propagated.
# iTerm profile switching requires shell_integration to be installed anyways.
if [[ "iTerm2" == "$LC_TERMINAL" ]]; then
    if [ ! -f ~/.iterm2_shell_integration.zsh ]; then
        echo "Bootstrapping iTerm2 Shell Integration on a new machine through curl"
        curl -L https://iterm2.com/shell_integration/zsh -o ~/.iterm2_shell_integration.zsh
    fi
    test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
fi

if [[ "$LOCAL_TERMINAL_CATEGORY" != "EMBEDDED" ]]; then
    alias cd='__venv_aware_cd'
else
     echo "Limiting zsh initialization because inside vscode terminal."
fi
